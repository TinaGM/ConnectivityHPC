
R version 3.6.3 (2020-02-29) -- "Holding the Windsock"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-conda_cos6-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> require(spatialEco)
Loading required package: spatialEco
> require(sp)
Loading required package: sp
> require(usedist)
Loading required package: usedist
> require(rgeos)
Loading required package: rgeos
rgeos version: 0.5-3, (SVN revision 634)
 GEOS runtime version: 3.8.1-CAPI-1.13.3 
 Linking to sp version: 1.4-1 
 Polygon checking: TRUE 

> require(raster)
Loading required package: raster

Attaching package: ‘raster’

The following object is masked from ‘package:spatialEco’:

    shift

> require(spatstat)
Loading required package: spatstat
Loading required package: spatstat.data

Attaching package: ‘spatstat.data’

The following object is masked from ‘package:spatialEco’:

    ants

Loading required package: nlme

Attaching package: ‘nlme’

The following object is masked from ‘package:raster’:

    getData

Loading required package: rpart

spatstat 1.64-1       (nickname: ‘Help you I can, yes!’) 
For an introduction to spatstat, type ‘beginner’ 


Attaching package: ‘spatstat’

The following objects are masked from ‘package:raster’:

    area, rotate, shift

The following object is masked from ‘package:spatialEco’:

    shift

> require(igraph)
Loading required package: igraph

Attaching package: ‘igraph’

The following objects are masked from ‘package:spatstat’:

    diameter, edges, is.connected, vertices

The following object is masked from ‘package:raster’:

    union

The following object is masked from ‘package:rgeos’:

    union

The following objects are masked from ‘package:spatialEco’:

    knn, similarity

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

> require(sf)
Loading required package: sf
Linking to GEOS 3.8.1, GDAL 3.0.4, PROJ 6.3.1
> require(rgdal)
Loading required package: rgdal
rgdal: version: 1.4-8, (SVN revision 845)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 3.0.4, released 2020/01/28
 Path to GDAL shared files: 
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 6.3.1, February 10th, 2020, [PJ_VERSION: 631]
 Path to PROJ.4 shared files: /usr/local/usrapps/tcsi/env_tcsi/share/proj
 Linking to sp version: 1.4-1 
> require(gdistance)
Loading required package: gdistance
Loading required package: Matrix

Attaching package: ‘gdistance’

The following object is masked from ‘package:igraph’:

    normalize

The following object is masked from ‘package:spatialEco’:

    overlap

> require(otuSummary)
Loading required package: otuSummary
Loading required package: vegan
Loading required package: permute

Attaching package: ‘permute’

The following object is masked from ‘package:igraph’:

    permute

Loading required package: lattice

Attaching package: ‘lattice’

The following object is masked from ‘package:spatstat’:

    panel.histogram

This is vegan 2.5-6

Attaching package: ‘vegan’

The following object is masked from ‘package:igraph’:

    diversity

> require(gdata)
Loading required package: gdata
gdata: read.xls support for 'XLS' (Excel 97-2004) files ENABLED.

gdata: read.xls support for 'XLSX' (Excel 2007+) files ENABLED.

Attaching package: ‘gdata’

The following objects are masked from ‘package:raster’:

    resample, trim

The following object is masked from ‘package:stats’:

    nobs

The following object is masked from ‘package:utils’:

    object.size

The following object is masked from ‘package:base’:

    startsWith

> require(maptools)
Loading required package: maptools
Checking rgeos availability: TRUE
> require(tidyverse)
Loading required package: tidyverse
Registered S3 method overwritten by 'cli':
  method     from    
  print.boxx spatstat
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.1     ✔ dplyr   1.0.0
✔ tidyr   1.1.0     ✔ stringr 1.4.0
✔ readr   1.3.1     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::as_data_frame() masks tibble::as_data_frame(), igraph::as_data_frame()
✖ dplyr::collapse()      masks nlme::collapse()
✖ dplyr::combine()       masks gdata::combine()
✖ purrr::compose()       masks igraph::compose()
✖ tidyr::crossing()      masks igraph::crossing()
✖ tidyr::expand()        masks Matrix::expand()
✖ tidyr::extract()       masks raster::extract()
✖ dplyr::filter()        masks stats::filter()
✖ dplyr::first()         masks gdata::first()
✖ dplyr::groups()        masks igraph::groups()
✖ purrr::keep()          masks gdata::keep()
✖ dplyr::lag()           masks stats::lag()
✖ dplyr::last()          masks gdata::last()
✖ tidyr::pack()          masks Matrix::pack()
✖ dplyr::select()        masks raster::select()
✖ purrr::simplify()      masks igraph::simplify()
✖ tidyr::unpack()        masks Matrix::unpack()
> require(reshape2)
Loading required package: reshape2

Attaching package: ‘reshape2’

The following object is masked from ‘package:tidyr’:

    smiths

> require(data.table)
Loading required package: data.table

Attaching package: ‘data.table’

The following objects are masked from ‘package:reshape2’:

    dcast, melt

The following objects are masked from ‘package:dplyr’:

    between, first, last

The following object is masked from ‘package:purrr’:

    transpose

The following objects are masked from ‘package:gdata’:

    first, last

The following object is masked from ‘package:spatstat’:

    shift

The following object is masked from ‘package:raster’:

    shift

The following object is masked from ‘package:spatialEco’:

    shift

> #setwd("C:/Users/zjrobbin/Documents/GitHub/ConnectivityHPC/")
> #getwd()
> #Create master map of all habitat created by a conservation strategy
> #args<-commandArgs(trailingOnly=TRUE)
> #i=as.numeric(args[1])
> eval(parse(text=paste(commandArgs(trailingOnly = TRUE), collapse=";")))
NULL
> 
> #Bring in ecoregion map to use for crs and extent template
> Ecoregion <- raster("Inputs/Ecoregion100f.tif")
> 
> #Bring in landis standmap
> Landis_standmap <- raster(paste("Inputs/Standmap100.tif",sep=""))
> 
> #Read in roads file
> roads <- raster(paste("Inputs/roads.tif",sep=""))
> 
> XO<- list.files("Inputs",pattern = "^geo(.*)tif$")
> ManyRunsStack<-raster::stack(paste0("Inputs/",XO))
> SumStack<-sum(ManyRunsStack)
> 
> rm(ManyRunsStack)
> 
> #Create empty vectors for connectivity indices
> nodes <- vector()
> links <- vector()
> avgnode <- vector()
> totnode <- vector()
> avgLCP <- vector()
> avgENN <- vector()
> density <- vector()
> transitivity <- vector()
> 
> #Time steps
> TimestepList <- as.character(seq(from=0, to=80, by=10))
> 
> #Connectivity analysis
>  
> 
> 
> Longleaf<-"PinuPalu"
> Loblolly<-"PinuTaed"
> Pine<- c("PinuEchi","PinuTaed","PinuVirg")
> Hardwood<-c("QuerAlba","AcerRubr","LiriTuli","LiquStyr","OxydArbo","CornFlor")
> 
> Year0<-list.files("Inputs",pattern=(".img$"))
> 
> Longleaf_Stack<-raster(paste0("Inputs/",Year0[Year0 %in% paste0("bio-", Longleaf,"-",i,".img")]))
> Loblolly_Stack<-raster(paste0("Inputs/",Year0[Year0 %in% paste0("bio-", Loblolly,"-",i,".img")]))
> Pine_Stack<-raster::stack(paste0("Inputs/",Year0[Year0 %in% paste0("bio-", Pine,"-",i,".img")]))
> Hardwood_Stack<-raster::stack(paste0("Inputs/",Year0[Year0 %in% paste0("bio-", Hardwood,"-",i,".img")]))
> Total<-raster(paste0("Inputs/",Year0[Year0 %in% paste0("bio-TotalBiomass-", i, ".img")]))
> 
> 
> ###Reclassification of biomass into community types
> 
> ###Rule 1 
> Longleaf_Stack[Longleaf_Stack> 0.25*(Total),]<-1
> Longleaf_Stack[!Longleaf_Stack==1]<-999
> ### Rule 2
> Loblolly_Stack[Loblolly_Stack> 0.9*(Total),]<-2
> Loblolly_Stack[!Loblolly_Stack==2]<-999
> ### Rule 3
> Pine_Stack[Pine_Stack> 0.65*(Total),]<-3
> Pine_Stack[!Pine_Stack==3]<-999
> ### Rule 4
> Hardwood_Stack[Hardwood_Stack>0.5*(Total),]<-4
> Hardwood_Stack[!Hardwood_Stack==4]<-999
> ### Rule 5
> Total[Total >0,]<-5
> 
> bigstack<-stack(Longleaf_Stack, Loblolly_Stack, Pine_Stack, Hardwood_Stack, Total)
> test_stack<-min(bigstack)
> crs(test_stack) <- "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> extent(test_stack)<-raster::extent(Ecoregion)
> 
> median0 <- raster(paste0('Inputs/',Year0[Year0 %in% paste0("AGE-MED-",i,".img")]))
> crs(median0) <- "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> extent(median0)<-raster::extent(Ecoregion)
> 
> #use to incorporate land use change
> #LU0 <- raster(paste("C:/Users/tgmozele/Desktop/LCP sensitivity test/geo2noLUC/land-use-", i, ".tif",sep=""))
> 
> #use to not incorporate land use change, but establish BAU land use types
> LU0 <- raster("Inputs/NLCD100.tif")
> 
> #Create a raster that will become resistance raster
> test_raster <- test_stack
> 
> #Assign projection and reformat to ecoregion extent for the resistance raster
> crs(test_raster) <- "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> extent(test_raster)<-raster::extent(Ecoregion)
> 
> #Assign values to resistance raster
> #longleaf community comp
> test_raster[test_stack == 1 & median0 %in% c(0:1),] <- (1/100)
> test_raster[test_stack == 1 & median0 %in% c(2:5),] <- (1/95)
> test_raster[test_stack == 1 & median0 %in% c(6:7),] <- (1/85)
> test_raster[test_stack == 1 & median0 %in% c(8:9),] <- (1/50)
> test_raster[test_stack == 1 & median0 %in% c(10:20),] <- (1/10)
> test_raster[test_stack == 1 & median0 %in% c(21:34),] <- (1/5)
> test_raster[test_stack == 1 & median0 >= 35,] <- 1
> #test_raster[test_stack == 3 & median0 %in% c(0:5),] <- (1/95)
> #test_raster[test_stack == 3 & median0 %in% c(6:10),] <- (1/80)
> #test_raster[test_stack == 3 & median0 %in% c(11:20),] <- (1/25)
> #test_raster[test_stack == 3 & median0 %in% c(21:34),] <- (1/5)
> #test_raster[test_stack == 3 & median0 >= 35,] <- 1
> 
> #pine plantation community type (was pine mix)
> test_raster[test_stack == 2 & median0 %in% c(0:5),] <- (1/100)
> test_raster[test_stack == 2 & median0 %in% c(6:10),] <- (1/90)
> test_raster[test_stack == 2 & median0 %in% c(11:20),] <- (1/80)
> test_raster[test_stack == 2 & median0 %in% c(21:30),] <- (1/70)
> test_raster[test_stack == 2 & median0 >= 31,] <- (1/60)
> 
> #pine mix community type (was lob_)
> test_raster[test_stack == 3 & median0 %in% c(0:5),] <- (1/95)
> test_raster[test_stack == 3 & median0 %in% c(6:10),] <- (1/80)
> test_raster[test_stack == 3 & median0 %in% c(11:20),] <- (1/40)
> test_raster[test_stack == 3 & median0 %in% c(21:34),] <- (1/30)
> test_raster[test_stack == 3 & median0 >= 35,] <- (1/20)
> #test_raster[test_stack == 3 & median0 %in% c(0:5),] <- (1/95)
> #test_raster[test_stack == 3 & median0 %in% c(6:10),] <- (1/80)
> #test_raster[test_stack == 3 & median0 %in% c(11:20),] <- (1/25)
> #test_raster[test_stack == 3 & median0 %in% c(21:34),] <- (1/5)
> #test_raster[test_stack == 3 & median0 >= 35,] <- 1
> 
> #hardwood community type (was mix)
> test_raster[test_stack == 4 & median0 %in% c(0:10),] <- (1/100)
> test_raster[test_stack == 4 & median0 %in% c(11:20),] <- (1/95)
> test_raster[test_stack == 4 & median0 %in% c(21:30),] <- (1/90)
> test_raster[test_stack == 4 & median0 >= 31,] <- (1/85)
> 
> #mixed forest community type (was hardwood)
> test_raster[test_stack == 5 & median0 %in% c(0:10),] <- (1/100)
> test_raster[test_stack == 5 & median0 %in% c(11:20),] <- (1/95)
> test_raster[test_stack == 5 & median0 %in% c(21:30),] <- (1/90)
> test_raster[test_stack == 5 & median0 >= 31,] <- (1/80)
> #test_raster[test_stack == 5 & median0 %in% c(0:10),] <- (1/100)
> #test_raster[test_stack == 5 & median0 %in% c(11:20),] <- (1/85)
> #test_raster[test_stack == 5 & median0 %in% c(21:30),] <- (1/70)
> #test_raster[test_stack == 5 & median0 >= 31,] <- (1/60)
> 
> test_raster2 <- test_raster
> 
> test_raster2[test_raster ==0] <- NA
> 
> #land use types
> test_raster2[LU0 == 82] <- (1/90) #cropland
> test_raster2[LU0 == 81] <- (1/90) #hay/pasture
> test_raster2[LU0 == 11] <- (1/100) #water
> test_raster2[LU0 == 24] <- (1/100) #developed, high intensity
> test_raster2[LU0 == 23] <- (1/95) #developed, med intensity
> test_raster2[LU0 == 22] <- (1/85) #developed, low intensity
> test_raster2[LU0 == 31] <- (1/90) #barren land
> #test_raster2[LU0 == 6] <- (1/100) #mining
> 
> test_raster2[test_raster2 ==0] <- (1/90)
> 
> #roads
> test_raster2[roads %in% c(1:2)] <- (1/100)
> test_raster2[roads %in% c(3:4)] <- (1/95)
> test_raster2[roads %in% c(5:89)] <- (1/90)
> 
> test_raster3 <- test_raster2
> test_raster3[test_raster3 >0.1] <- 1
> test_raster3[test_raster3 < 1] <- 0
> habitat_raster <- overlay(test_raster3, SumStack, fun=function(x,y){(x*y)} )
> 
> #Cluster habitat cells into habitat nodes using quintiles of occurrence
> 
> LikelyHabitat8<-habitat_raster
> LikelyHabitat8[LikelyHabitat8%in%c(0:36),]<-NA
> pol8 <- rasterToPolygons(LikelyHabitat8)
> proj4string(pol8) = "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> pol8$ID<-seq(1,length(pol8[1]))
> polbuf <- gBuffer(pol8, byid=TRUE, id=pol8$ID, width=1.0, quadsegs=5, capStyle="ROUND",
+                   joinStyle="ROUND", mitreLimit=1.0)
> polbufdis <- gUnaryUnion(polbuf, id = NULL, checkValidity=NULL)
> a<-raster::disaggregate(polbufdis)
> 
> LikelyHabitat5<-habitat_raster
> LikelyHabitat5[LikelyHabitat5%in%c(0:27,37:45),]<-NA
> pol5 <- rasterToPolygons(LikelyHabitat5)
> proj4string(pol5) = "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> pol5$ID<-seq(1,length(pol5[1]))
> polbuf <- gBuffer(pol5, byid=TRUE, id=pol5$ID, width=1.0, quadsegs=5, capStyle="ROUND",
+                   joinStyle="ROUND", mitreLimit=1.0)
> polbufdis <- gUnaryUnion(polbuf, id = NULL, checkValidity=NULL)
> b<-raster::disaggregate(polbufdis)
> 
> LikelyHabitat3<-habitat_raster
> LikelyHabitat3[LikelyHabitat3%in%c(0:18,28:45),]<-NA
> pol3 <- rasterToPolygons(LikelyHabitat3)
> proj4string(pol3) = "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> pol3$ID<-seq(1,length(pol3[1]))
> polbuf <- gBuffer(pol3, byid=TRUE, id=pol3$ID, width=1.0, quadsegs=5, capStyle="ROUND",
+                   joinStyle="ROUND", mitreLimit=1.0)
> polbufdis <- gUnaryUnion(polbuf, id = NULL, checkValidity=NULL)
> c<-raster::disaggregate(polbufdis)
> 
> LikelyHabitat1<-habitat_raster
> LikelyHabitat1[LikelyHabitat1%in%c(0:9,19:45),]<-NA
> pol1 <- rasterToPolygons(LikelyHabitat1)
> proj4string(pol1) = "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> pol1$ID<-seq(1,length(pol1[1]))
> polbuf <- gBuffer(pol1, byid=TRUE, id=pol1$ID, width=1.0, quadsegs=5, capStyle="ROUND",
+                   joinStyle="ROUND", mitreLimit=1.0)
> polbufdis <- gUnaryUnion(polbuf, id = NULL, checkValidity=NULL)
> d<-raster::disaggregate(polbufdis)
> 
> LikelyHabitat<-habitat_raster
> LikelyHabitat[LikelyHabitat%in%c(0,10:45),]<-NA
> pol <- rasterToPolygons(LikelyHabitat)
> proj4string(pol) = "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> pol$ID<-seq(1,length(pol[1]))
> polbuf <- gBuffer(pol, byid=TRUE, id=pol$ID, width=1.0, quadsegs=5, capStyle="ROUND",
+                   joinStyle="ROUND", mitreLimit=1.0)
> polbufdis <- gUnaryUnion(polbuf, id = NULL, checkValidity=NULL)
> e<-raster::disaggregate(polbufdis)
> 
> #Bring quintile-based habitat nodes together into one SpatialPolygonsDataFrame, find area of nodes, and assign numbers
> polys <- bind(a,b,c,d,e)
> data<-data.frame(ID=seq(1,length(polys)))
> pol1_dis<-SpatialPolygonsDataFrame(polys,data)
> pol1_dis$area_ha <- raster::area(pol1_dis)/10000
> 
> pol1_dis$num1 <- seq(from = 1, to= length(pol1_dis), by=1)
> pol1_dis$num2 <- seq(from = 1, to= length(pol1_dis), by=1)
> 
> #Assign weight to habitat by type and area to be used in Conefor
> pol1_dis$weight <- NA
> pol1_dis$weight <- log(pol1_dis$area_ha)
> 
> #Restrict habitat patches to those 2 hectares and larger, reassign ID's
> pol1_dis <- pol1_dis[pol1_dis$area_ha >= 2,]
> pol1_dis$ID<-seq(from = 1, to= length(pol1_dis), by=1)
> 
> #Make habitat nodes file to be used for Conefor
> maketext <- cbind(pol1_dis$ID, pol1_dis$weight)
> write.table(maketext, file=paste0("Outputs/nodes_TMgeos1_Thisoneisdiffernt78",i,".txt"), sep = "\t", row.names = FALSE, col.names = FALSE)
> 
> proc.time()
   user  system elapsed 
394.835  16.747 420.642 
